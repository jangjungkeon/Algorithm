import sys


N = int(sys.stdin.readline().strip())

# 1일 때 견제
if N == 1:
    print(1)
# 나머지 경우는 모두
else:
    print(int(0.5 * (3 + (9-4*(8-N)/3)**(0.5))))

    '''
    
    벌집의 규칙을 찾는 부분. 규칙이 어렵지는 않다. 
    다만 고민해봐야 할 것이. 메모리를 사용해서
    전체를 그린 후 찾는 방법을 고안할 것인가? 이게 가장 정확하긴 하다. 

    그러나 다른 천재적인 방법이 또 없을까? 고건 또 모르겠네 

    아니면 그냥 규칙이 있나? 

    이렇게 풀면 될듯  ~.~ 배불렁~
    1 : 1       // 1    / 0
    2 ~ 7 : 2   // 2 <= x < 8 / 6
    8 ~ 19 : 3  // 8 <= x < 20 / 12
    20 : 37 : 4 // 20 <= x < 38 / 18
    그렇다면 위의 규칙을 찾는게 급선무일 듯.
    a = 1
    d = 6(n-1)
    n 을 받으면 그것의 i 를 추적하는 것이 필요. 

    어느 범위에 속하는지 확인하는 것이 필요. 그러면 어떻게 확인함? 
    i = 1                     x = 1        
    i = 2      6*n - 10 <= N < 6*n - 4 
    n <= (N+10)/6
    n > (N+4)/6
    (N+4)/6 < n <= (N+10)/6

    start = (N+4)/6
    end = (N+10)/6
    print(start, end)
    어떤 값이 위에 속하는지 알면됨. 
    '''
    '''
    (N+4)/6 < n <= (N+10)/6
    N은 위와 같은 부등식을 만족해야하고, 정수를 얻어야 하므로
    int((N+4)/6)가 맞는 답, 가우스 기호 안의 (N+4)/6 이라고 해도 맞을듯. 
    '''

'''
보니깐 수학을 간단하게 바꿔야되는 거든대... 휴 스바. 계차 수열까지는 맞았으나
그 후에는 반복문으로 값을 추가하면 되는 거였다. 괜히 계산해서 식으로 딱 들어맞는 수를 찾으려니 오래 걸렸던것. 
즉, 수학과 알고리즘 수학을 동일시에 두고 풀었다는 것. 그렇게 좋은 결과가 나오지는 않았다. 
'''
